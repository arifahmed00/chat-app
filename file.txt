src/
    config/
        db.js

        const mongoose = require('mongoose');
        const { MONGO_URI } = require('./envConfig');
        require('dotenv').config();

        const connectDB = async () => {
            try {
                await mongoose.connect(MONGO_URI);
                console.log('MongoDB connected successfully');
            } catch (err) {
                console.error('MongoDB connection error:', err.message);
                process.exit(1);
            }
        }
        module.exports = connectDB;

        envConfig.js

        const dotenv = require('dotenv');
        dotenv.config();

        exports.MONGO_URI = process.env.MONGO_URI;
        exports.PORT = process.env.PORT;
        exports.JWT_SECRET = process.env.JWT_SECRET;
        exports.ACCESS_TOKEN_EXPIRES_IN = process.env.ACCESS_TOKEN_EXPIRES_IN;
        exports.REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN;




    middlewere/
        auth.js
            const jwt = require('jsonwebtoken');
            const {JWT_SECRET} = require("../config/envConfig")

            exports.chackUserToken = (req, res, next) => {
            const authHeader = req.headers['authorization'] || req.headers['Authorization'];
            if (!authHeader) return res.status(401).json({ error: 'Access token missing or invalid' });

            const token = authHeader.split(' ')[1];
            try {
                const decoded = jwt.verify(token, JWT_SECRET);
                req.user = decoded; // { id, username, role }
                next();
            } catch {
                res.status(401).json({ error: 'Invalid or expired token' });
            }
            };

            exports.chackAdminToken = async(req,res,next) =>{
            const authHeader = req.headers['authorization'] || req.headers['Authorization'];

            if (!authHeader) return res.status(401).json({ error: 'Admin access token missing or invalid' });
            const token = authHeader.split(' ')[1];
            try{
                const decoded = jwt.verify(token,JWT_SECRET)
                if (decoded.role !='admin'){
                return res.status(403).json({massage: "Access denied. Admins only."})
                }
                req.user = decoded
                next()
            }
            catch(error){
                return res.status(403).json({  message: 'Invalid or expired token'})
            }
            }

    module/
        conversation/
            conversation.Controller.js

                const Conversation = require('./Conversation.model');

                exports.startConversation = async (req, res) => {
                const { participants } = req.body; // array of usernames
                if (participants.length < 2) {
                    return res.status(400).json({ error: "At least two participants are required" });
                }

                try {
                    let conversation = await Conversation.findOne({
                    participants: { $all: participants }
                    });

                    if (!conversation) {
                    conversation = await Conversation.create({ participants });
                    }

                    res.status(200).json(conversation);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };

                exports.getUserConversations = async (req, res) => {
                const { username } = req.body;
                try {
                    const conversations = await Conversation.find({
                    participants: { $in: [username] }
                    });
                    res.json(conversations);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };


            conversation.model.js 
                const mongoose = require("mongoose");

                const ConversationSchema = new mongoose.Schema(
                {
                    participants: [{ type: String, required: true }]
                },{ timestamps: true }
                );

                module.exports = mongoose.model("Conversation", ConversationSchema);

            conversation.route.js
                const express = require('express');
                const router = express.Router();
                const {startConversation,getUserConversations}= require('./conversation.Controller')

                router.post('/start', startConversation);
                router.get('/:username', getUserConversations);

                module.exports = router;


        message/
            message.controller.js

                const Message = require('./Message.model');

                exports.sendMessage = async (req, res) => {
                const { conversationId, sender, text } = req.body;
                if (!conversationId || !sender || !text) {
                    return res.status(400).json({ error: "conversationId, sender, and text are required" });
                }

                try {
                    const message = await Message.create({ conversationId, sender, text });
                    res.status(201).json(message);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };

                exports.getMessages = async (req, res) => {
                const { conversationId } = req.body;
                try {
                    const messages = await Message.find({ conversationId });
                    res.json(messages);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };



            message.model.js
                const mongoose = require("mongoose");
                const { Schema } = mongoose;

                const MessageSchema = new Schema(
                {
                    conversationId: { type: Schema.Types.ObjectId, ref: "Conversation", required: true },
                    sender: { type: String, required: true }, // username
                    text: { type: String, required: true }
                },
                { timestamps: true }
                );

                module.exports = mongoose.model("Message", MessageSchema);

            message.route.js

                const express = require("express");
                const router = express.Router();
                const { sendMessage, getMessages } = require('./message.controller');

                router.post("/send", sendMessage);
                router.get("/:conversationId", getMessages);

                module.exports = router;


        user/
            user.Controller.js
                const User = require('./User.model');
                const jwt = require('jsonwebtoken');
                const bcrypt = require('bcrypt');
                const { ACCESS_TOKEN_EXPIRES_IN,JWT_SECRET,REFRESH_TOKEN_EXPIRES_IN } = require('../../config/envConfig');

                // REGISTER
                exports.register = async (req, res) => {
                try {
                    const { username, password, role } = req.body;
                    const user = await User.create({ username, password, role });
                    res.status(201).json({ user });
                } catch (err) {
                    res.status(400).json({ error: err.message });
                }
                };

                // LOGIN
                exports.login = async (req, res) => {
                const { username, password } = req.body;

                    const user = await User.findOne({ username });
                    if (!user) return res.status(404).json({ error: 'User not found' });

                    const valid = await bcrypt.compare(password, user.password);
                    if (!valid) return res.status(400).json({ error: 'Invalid password' });

                    const accessToken = jwt.sign(
                    { id: User._id, username: User.username, role: User.role },
                    JWT_SECRET,
                    { expiresIn: ACCESS_TOKEN_EXPIRES_IN }
                    );
                    const refreshToken = jwt.sign(
                    { userId: User._id },
                    JWT_SECRET,
                    { expiresIn: REFRESH_TOKEN_EXPIRES_IN }
                    )
                    user.refreshToken = refreshToken;
                    await user.save()
                    res.json({ accessToken,refreshToken });
                }

                exports.getAllUser = async () => {
                return await User.find();
                };

            user.model.js


                const mongoose = require('mongoose');
                const bcrypt = require('bcrypt');
                const { Schema } = mongoose;

                const UserSchema = new Schema({
                username: { type: String, required: true, unique: true },
                password: { type: String, required: true ,unique:true},
                role: { type: String, enum: ['user', 'admin'], default: 'user' },
                refreshToken: String,
                }, { timestamps: true });

                UserSchema.pre('save', async function (next) {
                if (!this.isModified('password')) return next();
                this.password = await bcrypt.hash(this.password, 10);
                next();
                });

                module.exports = mongoose.model('User', UserSchema);


            user.route.js
                const express = require('express');
                const router = express.Router();
                const {register,login,getAllUser} = require('./user.Controller');
                const { chackUserToken, chackAdminToken} = require('../../middleware/auth');

                router.post('/register', register);
                router.post('/login', login);
                router.get('/get-uers',chackUserToken, chackAdminToken,getAllUser);    //for admin

                module.exports = router;


.env
    PORT=4000
    MONGO_URI=mongodb+srv://main-BDcallingAccademy:pass@bdcallingaccademy.q20nqrt.mongodb.net/chat-app-backend
    JWT_SECRET=yourSuperSecretKey
    ACCESS_TOKEN_EXPIRES_IN=15m
    REFRESH_TOKEN_EXPIRES_IN=7d

app.js
    const express = require('express')
    const router = express.Router();
    const userRoutes = require('./src/module/user/users.route');
    const conversationRoutes = require('./src/module/conversation/conversations.route');
    const messageRoutes = require('./src/module/message/messages.route');


    // Routes
    router.use('/api/users', userRoutes);
    router.use('/api/conversations', conversationRoutes);
    router.use('/api/messages', messageRoutes);

    module.exports = router
server.js
    const dotenv = require('dotenv');
    const express = require('express');
    const connectDB = require('./src/config/db');
    const appRoutes = require('./app');
    const { PORT } = require('./src/config/envConfig.js');

    dotenv.config();
    const app = express();

    app.use(express.json());
    app.use(require('cors')());
    connectDB()
    app.use('/api',appRoutes)

    app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

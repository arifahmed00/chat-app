src/
    config/
        db.js
        const mongoose = require('mongoose');
        const { MONGO_URI } = require('./envConfig');
        require('dotenv').config();

        const connectDB = async () => {
        try {
        await mongoose.connect(MONGO_URI);
        console.log('MongoDB connected successfully');
        } catch (err) {
        console.error('MongoDB connection error:', err.message);
        process.exit(1);
        }
        }

        module.exports = connectDB;

        envConfig.js
        const dotenv = require('dotenv');
        dotenv.config();

        exports.MONGO_URI = process.env.MONGO_URI;
        exports.PORT = process.env.PORT;
        exports.JWT_SECRET = process.env.JWT_SECRET;
        exports.ACCESS_TOKEN_EXPIRES_IN = process.env.ACCESS_TOKEN_EXPIRES_IN;
        exports.REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN;




    middlewere/
        auth.js
            const jwt = require('jsonwebtoken');
            const {JWT_SECRET} = require("../config/envConfig")

            exports.chackUserToken = (req, res, next) => {
            const authHeader = req.headers[authorization] || req.headers[authorization];
            if (!authHeader) return res.status(401).json({ error: 'Access token missing or invalid' });

            const token = authHeader.split(' ')[1];
            try {
                const decoded = jwt.verify(token, JWT_SECRET);
                req.user = decoded; // { id, username, role }
                next();
            } catch {
                res.status(401).json({ error: 'Invalid or expired token' });
            }
            };

            exports.chackAdminToken = async(req,res,next) =>{
            const authHeader = req.headers['authorization'] || req.headers['Authorization'];

            if (!authHeader) return res.status(401).json({ error: 'Admin access token missing or invalid' });
            const token = authHeader.split(' ')[1];
            try{
                const decoded = jwt.verify(token,JWT_SECRET)
                if (decoded.role !='admin'){
                return res.status(403).json({massage: "Access denied. Admins only."})
                }
                req.user = decoded
                next()
            }
            catch(error){
                return res.status(403).json({  message: 'Invalid or expired token'})
            }
            }

    module/
        conversation/
            conversation.Controller.js
                const Conversation = require('./Conversation.model');

                exports.startConversation = async (req, res) => {
                const { participants } = req.body; // array of usernames
                if (participants.length < 2) {
                    return res.status(400).json({ error: "At least two participants are required" });
                }

                try {
                    let conversation = await Conversation.findOne({
                    participants: { $all: participants }
                    });

                    if (!conversation) {
                    conversation = await Conversation.create({ participants });
                    }

                    res.status(200).json(conversation);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };

                exports.getUserConversations = async (req, res) => {
                const { username } = req.params;
                try {
                    const conversations = await Conversation.find({
                    participants: { $in: [username] }
                    });
                    res.json(conversations);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };
                    
            conversation.model.js 
                const mongoose = require("mongoose");

                const ConversationSchema = new mongoose.Schema(
                {
                    participants: [
                    { type: String, required: true } // usernames       
                    ]
                },
                { timestamps: true }
                );

                module.exports = mongoose.model("Conversation", ConversationSchema);

            conversation.route.js
                const express = require('express');
                const router = express.Router();
                const ctrl = require('./conversation.Controller')
                router.post('/start', ctrl.startConversation);
                router.get('/:username', ctrl.getUserConversations);

                module.exports = router;


        message/
            message.Controller.js
                const Message = require('./Message.model');

                exports.sendMessage = async (req, res) => {
                const { conversationId, sender, text } = req.body;
                if (!conversationId || !sender || !text) {
                    return res.status(400).json({ error: "conversationId, sender, and text are required" });
                }

                try {
                    const message = await Message.create({ conversationId, sender, text });
                    res.status(201).json(message);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };

                exports.getMessages = async (req, res) => {
                const { conversationId } = req.params;
                try {
                    const messages = await Message.find({ conversationId });
                    res.json(messages);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                };


            message.model.js
                const mongoose = require("mongoose");
                const { Schema } = mongoose;

                const MessageSchema = new Schema(
                {
                    conversationId: { type: Schema.Types.ObjectId, ref: "Conversation", required: true },
                    sender: { type: String, required: true }, // username
                    text: { type: String, required: true }
                },
                { timestamps: true }
                );

                module.exports = mongoose.model("Message", MessageSchema);

            message.route.js
                // routes/messages.js
                const express = require("express");
                const router = express.Router();
                const Message = require("./Message.model");
                const Conversation = require("../conversation/Conversation.model");
                const User = require("../user/User.model");

                // Send a message
                router.post("/send", async (req, res) => {
                const { sender, receiver, text } = req.body;

                try {
                    // Find conversation between the users
                    let conversation = await Conversation.findOne({
                    participants: { $all: [sender, receiver] },
                    });

                    // If no conversation exists, create one
                    if (!conversation) {
                    conversation = await Conversation.create({
                        participants: [sender, receiver],
                    });
                    }

                    // Create the message
                    const message = await Message.create({
                    conversationId: conversation._id,
                    sender,
                    text,
                    });

                    res.status(201).json(message);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                });

                // Get all messages of a conversation
                router.get("/:conversationId", async (req, res) => {
                try {
                    const messages = await Message.find({
                    conversationId: req.params.conversationId,
                    }).populate("sender", "username");
                    res.json(messages);
                } catch (err) {
                    res.status(500).json({ error: err.message });
                }
                });

                module.exports = router;

        user/
            user.Controller.js
                const User = require('./User.model');
                const jwt = require('jsonwebtoken');
                const bcrypt = require('bcrypt');
                const { ACCESS_TOKEN_EXPIRES_IN,JWT_SECRET,REFRESH_TOKEN_EXPIRES_IN } = require('../../config/envConfig');

                // REGISTER
                exports.register = async (req, res) => {
                try {
                    const { username, password, role } = req.body;
                    const user = await User.create({ username, password, role });
                    res.status(201).json({ message: 'User created successfully' });
                } catch (err) {
                    res.status(400).json({ error: err.message });
                }
                };

                // LOGIN
                exports.login = async (req, res) => {
                const { username, password } = req.body;

                    const user = await User.findOne({ username });
                    if (!user) return res.status(404).json({ error: 'User not found' });

                    const valid = await bcrypt.compare(password, user.password);
                    if (!valid) return res.status(400).json({ error: 'Invalid password' });

                    const accessToken = jwt.sign(
                    { id: user._id, username: user.username, role: user.role },
                    JWT_SECRET,
                    { expiresIn: ACCESS_TOKEN_EXPIRES_IN }
                    );
                    const refreshToken = jwt.sign(
                    { userId: user._id },
                    JWT_SECRET,
                    { expiresIn: REFRESH_TOKEN_EXPIRES_IN }
                    )
                    user.refreshToken = refreshToken;
                    await user.save()
                    res.json({ accessToken,refreshToken });
                }

                exports.getAllUser = async () => {
                return await User.find();
                };


            user.model.js

            const mongoose = require('mongoose');
            const bcrypt = require('bcrypt');
            const { Schema } = mongoose;

            const UserSchema = new Schema({
            username: { type: String, required: true, unique: true },
            password: { type: String, required: true },
            role: { type: String, enum: ['user', 'admin'], default: 'user' },
            refreshToken: String,
            }, { timestamps: true });

            UserSchema.pre('save', async function (next) {
            if (!this.isModified('password')) return next();
            this.password = await bcrypt.hash(this.password, 10);
            next();
            });

            module.exports = mongoose.model('User', UserSchema);

            user.route.js

.env
    PORT=4000
    MONGO_URI=mongodb+srv://main-BDcallingAccademy:pass@bdcallingaccademy.q20nqrt.mongodb.net/chat-app-backend
    JWT_SECRET=yourSuperSecretKey
    ACCESS_TOKEN_EXPIRES_IN=15m
    REFRESH_TOKEN_EXPIRES_IN=7d

app.js
    const express = require('express')
    const router = express.Router();
    const userRoutes = require('./src/module/user/users.route');
    const conversationRoutes = require('./src/module/conversation/conversations.route');
    const messageRoutes = require('./src/module/message/messages.route');


    // Routes
    router.use('/api/users', userRoutes);
    router.use('/api/conversations', conversationRoutes);
    router.use('/api/messages', messageRoutes);

    module.exports = router
server.js
    const dotenv = require('dotenv');
    const express = require('express');
    const connectDB = require('./src/config/db');
    const appRoutes = require('./app');
    const { PORT } = require('./src/config/envConfig.js');

    dotenv.config();
    const app = express();

    app.use(express.json());
    app.use(require('cors')());
    connectDB()
    app.use('/api',appRoutes)

    app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
